# -*- coding: utf-8 -*-
"""
Created on Fri May 06 14:44:56 2016
 
@author: Adam
"""
 
#########################################################################
#                 Final Project - Sorting animations                    #
#                                                                       #
#   PROGRAMMED BY   Adam Sutton (May 1, 2016)                           #
#   CLASS           CS301, Spring 2016                                  #
#   INSTRUCTOR      Dean Zeller                                         #
#                                                                       #
#   DESCRIPTION                                                         #
#   This file contains functions to animated the bubble, selection      #
#   insertion, heap, and quick sort algorithms                          #
#                                                                       #
#   Classes and Functions                                               #
#   numbers class                                                       #
#       genNumbers - generates an array of 50 or X random numbers       #
#       heapSort - sets up heapsort so it can be called recursively     #
#       recHeapSort - bulk of the heap sort algorithm                   #
#       make_heap - starts making the heap sorts child and parent values#
#       switch - swaps values for the heap sort                         #
#       quicksort - sets up the quick sort so it can use recursion      #
#       recQuickSort - bulk of the quick sort algorithm                 #
#       partitionIt- sets left and right marks for quick sort           #
#       swap - swaps values for the quick sort                          #
#       insertionSort- sorts the array using the insertion algorithm    #
#       selectionSort - sorts the array using the selection algorithm   #
#       bubbleSort - sorts the array using the bubble sort algroithm    #
#                                                                       #
#   controller class - initiates the created of the tkinter gui         #
#       genButtonEvent - creates 50 random numbers or X numbers if      #
#       specified.                                                      #
#                                                                       #  
#   view class - creates the window for the graph to be placed in       # 
#       drawGraph - re-draws the graph at its current state             #
#       updateComps - updates the total number of swaps on the display  #      
#########################################################################
 
import random
from Tkinter import *
import time
 
comps = 0
hcomps = 0
 
class numbers(object):
     
    def __init__(self):
        self.genNumbers(50)
         
#       genNumbers - generates an array of 50 or X random numbers       #    
    def genNumbers(self, num):
        self.numberList = []
        for i in range(num):
            self.numberList.append(random.randint(1,290))
        appWindow.drawGraph(self.numberList)
         
#       heapSort - sets up heapsort so it can be called recursively     #        
    def heapSort(self):
        self.recHeapSort(len(self.numberList), len(self.numberList)//2-1)
         
#       recHeapSort - bulk of the heap sort algorithm                   #        
    def recHeapSort(self, end, start):
        global comps
        for i in range(start, -1, -1):
             
            self.make_heap(end, i)
            time.sleep(0.1)
            appWindow.drawGraph(self.numberList)
             
            root.update_idletasks()
            
             
        for i in range(end-1, 0, -1):   
            self.switch(i, 0)
             
            self.make_heap(i, 0)
            time.sleep(0.1)
            appWindow.drawGraph(self.numberList)
            root.update_idletasks()
         
#       make_heap - starts making the heap sorts child and parent values#           
    def make_heap(self,end,i):
             
             
            l=2 * i + 1 
            r=2 * (i + 1)   
            max=i   
            if l < end and self.numberList[i] < self.numberList[l]:   
                max = l   
            if r < end and self.numberList[max] < self.numberList[r]:   
                max = r   
            if max != i:   
                self.switch(i, max)
                 
                self.make_heap(end, max)
            appWindow.updateComps(hcomps)
                 
#       switch - swaps values for the heap sort                         #        
    def switch(self, i, j):
        global hcomps  
        hcomps = hcomps + 1                
        self.numberList[i], self.numberList[j] = self.numberList[j], self.numberList[i]
        appWindow.updateComps(hcomps)
         
#       quicksort - sets up the quick sort so it can use recursion      #        
    def quickSort(self):    
        self.recQuickSort(0, len(self.numberList) - 1)
         
#       recQuickSort - bulk of the quick sort algorithm                 #  
    def recQuickSort(self, left, right):
         
        if right-left <= 0:  
            return 
        else:    
            pivot = self.numberList[right]  
            partition = self.partitionIt(left, right, pivot)
            self.recQuickSort(left, partition-1)   
            self.recQuickSort(partition+1, right)
             
         
             
         
#       partitionIt- sets left and right marks for quick sort           #  
    def partitionIt(self, left, right, pivot):
         
         
         
        leftMark = left-1   
        rightMark = right
        while True:
            leftMark += 1
            while self.numberList[leftMark] < pivot:
                    leftMark += 1
            rightMark -= 1
            while rightMark > 0 and self.numberList[rightMark] > pivot:
                    rightMark -= 1
            if leftMark >= rightMark: 
                break   
            else:    
                self.swap(leftMark, rightMark)
                 
                appWindow.updateComps(comps)
        self.swap(leftMark, right)
         
        appWindow.updateComps(comps)
         
        return leftMark
         
         
         
 
#       swap - swaps values for the quick sort                          #  
    def swap(self, dex1, dex2): 
        global comps
        self.numberList[dex1], self.numberList[dex2] = self.numberList[dex2], self.numberList[dex1]
        comps = comps + 1
        time.sleep(0.1)
        appWindow.drawGraph(self.numberList)
        appWindow.updateComps(comps)
        root.update_idletasks()
     
#       insertionSort- sorts the array using the insertion algorithm    #    
    def insertionSort(self):
        compcount = 0
        for i in range(1, len(self.numberList)):
            j = i
            time.sleep(0.1)
            appWindow.drawGraph(self.numberList)
            root.update_idletasks()
            while j > 0 and self.numberList[j] < self.numberList[j-1]:
                self.numberList[j], self.numberList[j-1] = self.numberList[j-1], self.numberList[j]
                compcount = compcount + 1
                appWindow.updateComps(compcount)
                time.sleep(0.1)
                appWindow.drawGraph(self.numberList)
                root.update_idletasks()
                j -= 1 
                 
                 
        appWindow.updateComps(compcount)
     
#       bubbleSort- sorts the array using the bubble sort algorithm    #
    def bubbleSort(self):
        compcountB = 0
        for i in range(len(self.numberList)):
             
            for j in range(len(self.numberList)):
                 
                if self.numberList[j] > self.numberList[i]:
 
                    self.numberList[j], self.numberList[i] = self.numberList[i], self.numberList[j]
                    compcountB = compcountB + 1
                    appWindow.updateComps(compcountB)
                    time.sleep(0.1)
                    appWindow.drawGraph(self.numberList)
                    root.update_idletasks()
                     
        appWindow.updateComps(compcountB)
         
#       selectionSort- sorts the array using the selection algorithm    #           
    def selectionSort(self):
        compcountS = 0
        for i in range(len(self.numberList)-1,0,-1):
            positionOfMax=0
             
            for j in range(1,i+1):
                 
                if self.numberList[j]>self.numberList[positionOfMax]:
                    positionOfMax = j
                    compcountS = compcountS + 1
                    appWindow.updateComps(compcountS)
            temp = self.numberList[i]
             
            appWindow.updateComps(compcountS)
            self.numberList[i] = self.numberList[positionOfMax]
             
            appWindow.updateComps(compcountS)
            self.numberList[positionOfMax] = temp
             
            appWindow.updateComps(compcountS)
             
            time.sleep(0.1)
            appWindow.drawGraph(self.numberList)
            root.update_idletasks()
             
        appWindow.updateComps(compcountS)
   
class controller(object):
    def __init__(self, num):
 # creation of the interface #       
        self.title = Label(frame, text="Animated Sorting Algorithms", bg="blue", fg="gold")
        self.title.pack(side=TOP, fill=X)
         
        self.arrSize = Label(frame, text="Enter a custom array size", bg="blue", fg="gold")
        self.arrSize.pack(side=TOP, fill=X)
         
        self.entry = Entry(frame, width = 20)
        self.entry.pack(side=TOP)
         
         
        self.bubble = Button(frame,text ="Bubble Sort", command = num.bubbleSort)
        self.bubble.pack(side=LEFT, padx=13)
         
        self.selection = Button(frame, text = "Selection Sort", command = num.selectionSort)
        self.selection.pack(side=LEFT, padx=13)
         
        self.selection = Button(frame, text = "Insertion Sort", command = num.insertionSort)
        self.selection.pack(side=LEFT, padx=13)
         
        self.selection = Button(frame, text = "Quick Sort", command = num.quickSort)
        self.selection.pack(side=LEFT, padx=13)
         
        self.selection = Button(frame, text = "Heap Sort", command = num.heapSort)
        self.selection.pack(side=LEFT, padx=13)
         
        self.genButton = Button(frame,text ="New Numbers", command = self.genButtonEvent)
        self.genButton.pack(side=LEFT, padx=13)
         
#       genButtonEvent - creates 50 random numbers or X numbers if      #       
    def genButtonEvent(self):
        if self.entry.get().strip() == "":
            num.genNumbers(50)
        else:
            num.genNumbers(int(self.entry.get()))
             
                      
    
class view(object):
    def __init__(self):
         
         
        # creation of the canvas where the graph is built #
        self.canvas = Canvas(frame, height=400, width=600, relief=RAISED, bg='white')
        self.canvas.pack(side=TOP)
        self.leftRect = self.canvas.create_rectangle(10,10,580,300, fill = "white", outline="black")
         
        self.compOut = Label(frame, text="", bg="blue", fg="gold")
        self.compOut.pack(side=BOTTOM, fill=X)
         
        self.compL = Label(frame, text="Swaps Required", bg="red", fg="gold")
        self.compL.pack(side=BOTTOM, fill=X)
         
         
         
         
#       drawGraph - re-draws the graph at its current state             #
 
    def drawGraph(self, numList):
        self.canvas.delete(ALL)
        self.leftRect = self.canvas.create_rectangle(10,10,580,300, fill = "white", outline="black")
        x = 10
        spacing = 550 / len(numList)
        for i in range(len(numList)):
            x += spacing
            self.canvas.create_rectangle(x, 300-numList[i], x+5, 300, fill = "blue")
             
#       updateComps - updates the total number of swaps on the display  #             
    def updateComps(self, totalComps):
        result = totalComps
        self.compOut.config(text=result)
         
         
         
     
     
 
          
root = Tk()
frame = Frame(root)
frame.pack()
appWindow = view()
num = numbers()
c = controller(num)
root.mainloop()
root.destroy()
